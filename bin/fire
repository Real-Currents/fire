#!/usr/bin/env node
'use strict';

var dotenv = require('dotenv');
dotenv.load();

var path = require('path');
var fs = require('fs');
var Q = require('q');
var argv = require('minimist')(process.argv.slice(2));

var Models = require('./../lib/modules/models/models');

var Migrations = require('./../lib/modules/migrations/migrations');
var Generate = require('./../lib/modules/migrations/generate');

var mu = require('mu2');
mu.root = path.join(__dirname, 'templates');
var inflection = require('inflection');
var fire = require('./..');
var basePath = path.resolve('./');
var crypto = require('crypto');
var spawn = require('child_process').spawn;

function execute(command, params) {
	var defer = Q.defer();

	console.log(command + ' ' + (params || []).join(' '));

	var child = spawn(command, params, {stdio: 'inherit'});
	child.on('exit', function() {
		defer.resolve();
	});

	return defer.promise;
}

function start(scriptName) {
	var fireBin = process.mainModule.filename;

	var startChild = function() {
		execute(fireBin, ['generate', 'migrations'])
			.then(function() {
				return execute(fireBin, ['generate', 'scripts']);
			})
			.then(function() {
				return execute('npm', ['install']);
			})
			.then(function() {
				return execute('bower', ['install']);
			})
			.then(function() {
				return execute(fireBin, ['migrate']);
			})
			.then(function() {
				return execute('node', [scriptName]);
			})
			.then(function() {
				return Q.delay(1000);
			})
			.then(function() {
				startChild();
			})
			.done();
	};

	startChild();
}

if(argv._.length === 0) {
	start('index.js');
}
else if(argv._[0] == 'help') {
	console.log('todo: create a help section');
}
else if(argv._[0] == 'create') {
	var appName = argv._[1];

	var appPath = path.join(basePath, inflection.dasherize(appName).toLowerCase());
	console.log('Creating `' + appPath + '`.');

	fs.mkdirSync(appPath);

	var directories = ['templates', 'controllers', 'models', 'public'];
	directories.forEach(function(directory) {
		var directoryPath = path.join(appPath, directory);
		console.log('Creating `' + directoryPath + '`.');
		fs.mkdirSync(directoryPath);
	});

	var files = ['bower.json', 'index.js', '.env'];
	files.forEach(function(fileName) {
		var filePath = path.join(appPath, fileName);

		console.log('Creating `' + filePath + '`.');

		mu.compileAndRender(fileName, {
			name: appName,
			sessionKey: crypto.randomBytes(127).toString('base64')
		}).pipe(fs.createWriteStream(filePath));
	});
}
else if(argv._[0] == 'migrate') {
	var models = new Models();
	var migrations = new Migrations();

	var targetVersion = 0;

	// Set-up without reading any of the models
	// We will create the models based on all migrations
	models.setup(null)
		.then(function() {
			return migrations.setup(path.join(basePath, '_migrations'), models);
		})
		.then(function() {
			if(migrations._.length === 0) {
				throw new Error('There are 0 migration files. Did you run `fire generate migrations`?');
			}
		})
		.then(function() {
			// Let's find which database version we're at
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(typeof argv.v != 'undefined') {
				targetVersion = argv.v;
			}
			else if(typeof argv.version != 'undefined') {
				targetVersion = argv.version;
			}
			else {
				targetVersion = migrations._[migrations._.length - 1].version;
			}

			console.log('*** Migrating from `' + currentVersion + '` to `' + targetVersion + '`.');

			// TODO: First do a check if currentVersion and targetVersion are different OR do not throw an error in migrate when versions are the same.

			return migrations.migrate(currentVersion, targetVersion);
		})
		.then(function() {
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(currentVersion == targetVersion) {
				//everything went alright
				console.log('*** Migration successful to `' + targetVersion + '`.');
			}
			else {
				throw new Error('Database version after migration `' + currentVersion + '` does not match target version `' + targetVersion + '`.');
			}
		})
		.catch(function(error) {
			console.log(error.message);

			if(argv.d || argv.debug) {
				console.log(error.stack);
			}

			throw error;
		})
		.done();
}
else if(argv._[0] == 'generate' || argv._[0] == 'g') {
	if(argv._.length == 1) {
		throw new Error('You did not specify enough parameters. What do you want to generate? `migrations`?');
	}

	if(argv._[1] == 'migrations') {
		fs.mkdir(path.join(basePath, '_migrations'), function() {
			var generate = new Generate(argv._[2] ? path.resolve(argv._[2]) : basePath);
			generate.delegate = {
				addMigration: function(fileName, stream) {
					stream.pipe(fs.createWriteStream(path.join(basePath, '_migrations', fileName)));
				}
			};
			generate.createMigrations();
		});
	}
	else if(argv._[1] == 'scripts') {
		fire.disabled = true;

		var initialScript = 'index.js';
		if(argv._.length > 2) {
			initialScript = argv._[2];
		}

		require(path.join(basePath, initialScript));

		var app = fire.app();
		app.controllers.setup(basePath)
			.then(function() {
				return app.models.setup(basePath);
			})
			.then(function() {
				setImmediate(function() {
					var bridge = app.bridge;
					bridge.load();

					fs.mkdir(path.join(basePath, '_assets'), function() {
						var writeStream = fs.createWriteStream(path.join(basePath, '_assets', 'fire.js'));

						bridge.generate(writeStream);
					});
				});
			})
			.done();
	}
}
else if(argv._.length == 1 && argv._[0].match(/\.js$/)) {
	start(argv._[0]);
}
else {
	console.log('Unknown command...');
}
