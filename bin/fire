#!/usr/bin/env node
'use strict';

var dotenv = require('dotenv');
dotenv.load();

var path = require('path');
var fs = require('fs');

var argv = require('minimist')(process.argv.slice(2));

var Models = require('./../lib/modules/models/models');

var Migrations = require('./../lib/modules/migrations/migrations');
var Generate = require('./../lib/modules/migrations/generate');
var Monarch = require('./../lib/modules/monarch');

var mu = require('mu2');
mu.root = path.join(__dirname, '..', 'cli', 'templates');

var fire = require('./..');


var basePath = path.resolve('./');

if(argv._.length === 0) {
	//TODO: Show help.

	throw new Error('Hey. Not enough commands.');
}

if(argv._[0] == 'new') {
	// TODO: create an app
}
else if(argv._[0] == 'migrate') {
	var models = new Models();
	var migrations = new Migrations();

	var targetVersion = 0;

	// Set-up without reading any of the models
	// We will create the models based on all migrations
	return models.setup(null)
		.then(function() {
			return migrations.setup(path.join(basePath, '_migrations'), models);
		})
		.then(function() {
			// Let's find which database version we're at
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(typeof argv.v != 'undefined') {
				targetVersion = argv.v;
			}
			else if(typeof argv.version != 'undefined') {
				targetVersion = argv.version;
			}
			else {
				targetVersion = migrations._[migrations._.length - 1].version;
			}

			console.log('*** Migrating from `' + currentVersion + '` to `' + targetVersion + '`.');
			return migrations.migrate(currentVersion, targetVersion);
		})
		.then(function() {
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(currentVersion == targetVersion) {
				//everything went alright
				console.log('*** Migration successful to `' + targetVersion + '`.');
				return true;
			}
			else {
				throw new Error('Database version after migration `' + currentVersion + '` does not match target version `' + targetVersion + '`.');
			}
		})
		.fail(function(error) {
			console.log(error.message);

			if(argv.d || argv.debug) {
				console.log(error.stack);
			}

			return error;
		})
		.done();
}
else if(argv._[0] == 'generate' || argv._[0] == 'g') {
	if(argv._.length == 1) {
		throw new Error('You did not specify enough parameters. What do you want to generate? A `migration`?');
	}

	if(argv._[1] == 'migration') {
		var generate = new Generate(argv._[2]);
		generate.createMigration();
	}
	else if(argv._[1] == 'script' || argv._[1] == 'monarch') {
		var startPath = argv._[2] ? path.resolve(argv._[2]) : basePath;

		fire.disabled = true;

		fs.readdirSync(startPath).forEach(function(resourceFileName) {
			if(resourceFileName.length && resourceFileName[0] != '_' && resourceFileName[0] != '.') {
				var fullPath = path.join(basePath, resourceFileName);
				if(!fs.lstatSync(fullPath).isDirectory()) {
					require(fullPath);
				}
			}
		});

		var app = fire.app();
		app.controllers.setup(basePath)
			.then(function() {
				return app.models.setup(basePath);
			})
			.then(function() {
				setImmediate(function() {
					var monarch = new Monarch(app);
					monarch.load();

					fs.mkdir(path.join(basePath, '_assets'), function() {
						var writeStream = fs.createWriteStream(path.join(basePath, '_assets', 'fire.js'));

						monarch.generate(writeStream);
					});
				});		
			})
			.done();
	}
	else {
		// TODO: Generate a controller, worker, middleware (?), responder, etc
	}
}
else {
	// TODO: generate a database migration.
}
