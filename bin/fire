#!/usr/bin/env node
'use strict';

var dotenv = require('dotenv');
dotenv.load();

var path = require('path');
var fs = require('fs');
var Q = require('q');
var argv = require('minimist')(process.argv.slice(2));

var Models = require('./../lib/modules/models');

var Migrations = require('./../lib/modules/migrations');
var Generate = require('./../lib/modules/migrations/generate');

var mu = require('mu2');
mu.root = path.join(__dirname, 'templates');

var inflection = require('inflection');
var fire = require('./..');
var basePath = path.resolve('./');
var crypto = require('crypto');
var spawn = require('child_process').spawn;

function mkdir(dirPath) {
	var defer = Q.defer();
	fs.mkdir(dirPath, function() {
		defer.resolve(true);
	});
	return defer.promise;
}

function execute(command, params) {
	var defer = Q.defer();

	console.log(command + ' ' + (params || []).join(' '));

	var child = spawn(command, params, {stdio: 'inherit'});
	child.on('exit', function() {
		process.stdin.removeListener('readable', callback);
		defer.resolve();
	});

	var callback = function() {
		var chunk = process.stdin.read();
		if(chunk !== null) {
			child.kill();
		}
	};
	process.stdin.on('readable', callback);

	return defer.promise;
}

function start(scriptName) {
	var fireBin = process.mainModule.filename;
	process.stdin.setEncoding('utf8');

	var startChild = function() {
		execute(fireBin, ['build'])
			.then(function() {
				return execute(fireBin, ['migrate']);
			})
			.then(function() {
				return execute('node', [scriptName]);
			})
			.then(function() {
				return Q.delay(1000);
			})
			.then(function() {
				startChild();
			})
			.done();
	};

	startChild();
}

function showUsage() {
	var lines = [
		'Usage: fire COMMAND [command-specific-options]',
		'',
		'All available commands are listed below. For more information on a specific command, type "fire help COMMAND".',
		'',
		'	start		# builds, releases and runs your app',
		'	build		# generates migrations, scripts, api, installs dependencies',
		'	create		# creates a new app with a skeleton structure',
		'	migrate		# migrates the database',
		'	generate	# generates additional code',
		''
	];
	lines.forEach(function(line) {
		console.log(line);
	});
}

if(argv._.length === 0) {
	showUsage();
}
else if(argv._[0] == 'start') {
	// TODO: Should we deprecate this because we want to promote the build-release-run phases?
	start('index.js');
}
else if(argv._[0] == 'build') {
	var fireBin = process.mainModule.filename;
	execute(fireBin, ['generate', 'migrations'])
		.then(function() {
			return execute(fireBin, ['generate', 'scripts']);
		})
		.then(function() {
			return execute(fireBin, ['generate', 'api']);
		})
		.then(function() {
			return execute('npm', ['install']);
		})
		.then(function() {
			return execute('bower', ['install']);
		})
		.done();
}
else if(argv._[0] == 'help') {
	if(argv._.length == 1) {
		showUsage();
	}
	else {
		console.log('todo: show command-specific help');
	}
}
else if(argv._[0] == 'create') {
	var appName = argv._[1];

	var appPath = path.join(basePath, inflection.dasherize(appName).toLowerCase());

	if(fs.existsSync(appPath)) {
		throw new Error('Path `' + appPath + '` already exists.');
	}

	console.log('Creating `' + appPath + '`.');

	fs.mkdirSync(appPath);

	var directories = ['templates', 'controllers', 'models', 'public'];
	directories.forEach(function(directory) {
		var directoryPath = path.join(appPath, directory);
		console.log('Creating `' + directoryPath + '`.');
		fs.mkdirSync(directoryPath);
	});

	var filesMap = {
		'bower-json.mu': 'bower.json',
		'index-js.mu': 'index.js',
		'env.mu': '.env',
		'package-json.mu': 'package.json'
	};

	Object.keys(filesMap).forEach(function(from) {
		var to = filesMap[from];
		var filePath = path.join(appPath, to);

		console.log('Creating `' + filePath + '`.');

		mu.compileAndRender(from, {
			name: appName,
			sessionKey: crypto.randomBytes(127).toString('base64')
		}).pipe(fs.createWriteStream(filePath));
	});
}
else if(argv._[0] == 'migrate') {
	var models = new Models();
	var migrations = new Migrations();

	var targetVersion = 0;

	// Set-up without reading any of the models
	// We will create the models based on all migrations
	models.setup(null)
		.then(function() {
			return migrations.setup(path.join(basePath, '_migrations'), models);
		})
		.then(function() {
			if(migrations._.length === 0) {
				throw new Error('There are 0 migration files. Did you run `fire generate migrations`?');
			}
		})
		.then(function() {
			// Let's find which database version we're at
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(typeof argv.v != 'undefined') {
				targetVersion = argv.v;
			}
			else if(typeof argv.version != 'undefined') {
				targetVersion = argv.version;
			}
			else {
				targetVersion = migrations._[migrations._.length - 1].version;
			}

			console.log('*** Migrating from `' + currentVersion + '` to `' + targetVersion + '`.');

			// TODO: First do a check if currentVersion and targetVersion are different OR do not throw an error in migrate when versions are the same.

			return migrations.migrate(currentVersion, targetVersion);
		})
		.then(function() {
			return migrations.currentVersion();
		})
		.then(function(currentVersion) {
			if(currentVersion == targetVersion) {
				//everything went alright
				console.log('*** Migration successful to `' + targetVersion + '`.');
			}
			else {
				throw new Error('Database version after migration `' + currentVersion + '` does not match target version `' + targetVersion + '`.');
			}
		})
		.catch(function(error) {
			console.log(error.message);

			if(argv.d || argv.debug) {
				console.log(error.stack);
			}

			throw error;
		})
		.done();
}
else if(argv._[0] == 'generate' || argv._[0] == 'g') {

}
else if(argv._.length == 1 && argv._[0].match(/\.js$/)) {
	start(argv._[0]);
}
else {
	console.log('Unknown command...');
}
