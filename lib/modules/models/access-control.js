'use strict';

exports = module.exports = AccessControl;

var ModelInstance = require('./model-instance');

/**
 * AccessControl manages the permissions of create, read, update and delete actions on models. Only actions through the models API go through the access control. This effectively manages the permissions of the actions happening in the front-end, but leaves everything happening in the back-end untouched. Please remember this.
 *
 * The below example creates a simple Book model which only signed-in admin users are allowed to create.
 *
 * ```js
 * function Book() {
 * 	this.name = [this.String, this.Required];
 * }
 * app.model(Book);
 *
 * Book.prototype.accessControl = function() {
 * 	return {
 * 		canCreate: function(authenticator) {
 * 			return (authenticator && authenticator.isAdmin);
 * 		}
 * 	};
 * };
 * ```
 *
 * Please note the access control is only applied to the model controllers generated by the API. When calling any of the model methods directly no access control is applied.
 *
 * @constructor
 */
function AccessControl(app, accessControl) {
	this.app = app;
	this._ = accessControl;
}

AccessControl.prototype._canAccess = function(type, privateMap) {
	var accessFunction = this._[type];
	var canAccess = (accessFunction === true);

	if(typeof accessFunction == 'string') {
		throw new Error('Key path-based access control is deprecated.');
	}

	if(typeof accessFunction == 'function') {
		canAccess = this.app.injector.call(accessFunction, privateMap);
	}
	else if(typeof functionOrKeyPath == 'undefined') {
		if(!process.env.NODE_ENV || process.env.NODE_ENV == 'development') {
			console.log('Warning: no access control declared. In development environment access control will default to open, but in production the default will be closed to prevent security issues. To remove this warning, declare access control on your models.');
			canAccess = true;
		}
	}

	if(canAccess instanceof ModelInstance) {
		throw new Error('Model#accessControl() should not return a model instance. Instead, either true, false, or a key-value object transforming the where-map.');
	}

	return canAccess;
};

AccessControl.prototype.canCreate = function(privateMap, shouldBeUndefined) {
	if(typeof shouldBeUndefined != 'undefined') {
		throw new Error('AccessControl#canCreate changed to only accept one argument.');
	}

	return this._canAccess('canCreate', privateMap);
};

AccessControl.prototype.canRead = function(privateMap) {
	return this._canAccess('canRead', privateMap);
};

AccessControl.prototype.canUpdate = function(privateMap) {
	return this._canAccess('canUpdate', privateMap);
};

AccessControl.prototype.canDelete = function(privateMap) {
	return this._canAccess('canDelete', privateMap);
};

AccessControl.prototype.getPermissionFunction = function() {
	throw new Error('AccessControl#getPermissionFunction is deprecated. Please use Model#accessControl to declare access control.');
};

AccessControl.prototype.getPermissionKeyPath = function() {
	throw new Error('AccessControl#getPermissionKeyPath is deprecated.');
};
